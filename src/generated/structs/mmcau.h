/**
 * \file
 * \brief Generated by ifgen (3.3.0).
 */
#pragma once

#include "../enums/MMCAU_CASR_VER.h"
#include "../ifgen/common.h"

namespace MIMXRT1176::CM4
{

/**
 * CAU
 */
struct [[gnu::packed]] mmcau
{
    /* Constant attributes. */
    static constexpr std::size_t size = 44; /*!< mmcau's size in bytes. */

    /* Fields. */
    uint32_t CASR; /*!< (read-write) Status Register */
    uint32_t CAA;  /*!< (read-write) Accumulator */
    static constexpr std::size_t CA_length = 9;
    uint32_t CA[CA_length]; /*!< (read-write) General Purpose Register */

    /* Methods. */

    /**
     * Get CASR's VER field.
     *
     * CAU Version
     */
    inline MMCAU_CASR_VER get_CASR_VER() volatile
    {
        return MMCAU_CASR_VER((CASR >> 28u) & 0b1111u);
    }

    /**
     * Get CASR's DPE bit.
     *
     * DES Parity Error
     */
    inline bool get_CASR_DPE() volatile
    {
        return CASR & (1u << 1u);
    }

    /**
     * Set CASR's DPE bit.
     *
     * DES Parity Error
     */
    inline void set_CASR_DPE() volatile
    {
        CASR |= 1u << 1u;
    }

    /**
     * Clear CASR's DPE bit.
     *
     * DES Parity Error
     */
    inline void clear_CASR_DPE() volatile
    {
        CASR &= ~(1u << 1u);
    }

    /**
     * Toggle CASR's DPE bit.
     *
     * DES Parity Error
     */
    inline void toggle_CASR_DPE() volatile
    {
        CASR ^= 1u << 1u;
    }

    /**
     * Get CASR's IC bit.
     *
     * Illegal Command
     */
    inline bool get_CASR_IC() volatile
    {
        return CASR & (1u << 0u);
    }

    /**
     * Set CASR's IC bit.
     *
     * Illegal Command
     */
    inline void set_CASR_IC() volatile
    {
        CASR |= 1u << 0u;
    }

    /**
     * Clear CASR's IC bit.
     *
     * Illegal Command
     */
    inline void clear_CASR_IC() volatile
    {
        CASR &= ~(1u << 0u);
    }

    /**
     * Toggle CASR's IC bit.
     *
     * Illegal Command
     */
    inline void toggle_CASR_IC() volatile
    {
        CASR ^= 1u << 0u;
    }

    /**
     * Get all of CASR's bit fields.
     *
     * (read-write) Status Register
     */
    inline void get_CASR(MMCAU_CASR_VER &VER, bool &DPE, bool &IC) volatile
    {
        uint32_t curr = CASR;

        VER = MMCAU_CASR_VER((curr >> 28u) & 0b1111u);
        DPE = curr & (1u << 1u);
        IC = curr & (1u << 0u);
    }

    /**
     * Set all of CASR's bit fields.
     *
     * (read-write) Status Register
     */
    inline void set_CASR(bool DPE, bool IC) volatile
    {
        uint32_t curr = CASR;

        curr &= ~(0b1u << 1u);
        curr |= (DPE & 0b1u) << 1u;
        curr &= ~(0b1u << 0u);
        curr |= (IC & 0b1u) << 0u;

        CASR = curr;
    }

    /**
     * Get CAA's ACC field.
     *
     * Accumulator
     */
    inline uint32_t get_CAA_ACC() volatile
    {
        return (CAA >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set CAA's ACC field.
     *
     * Accumulator
     */
    inline void set_CAA_ACC(uint32_t value) volatile
    {
        uint32_t curr = CAA;

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        CAA = curr;
    }

    /**
     * Get CA's CAn field.
     *
     * General Purpose Registers
     */
    inline uint32_t get_CA_CAn(std::size_t index) volatile
    {
        return (CA[index] >> 0u) & 0b11111111111111111111111111111111u;
    }

    /**
     * Set CA's CAn field.
     *
     * General Purpose Registers
     */
    inline void set_CA_CAn(std::size_t index, uint32_t value) volatile
    {
        uint32_t curr = CA[index];

        curr &= ~(0b11111111111111111111111111111111u << 0u);
        curr |= (value & 0b11111111111111111111111111111111u) << 0u;

        CA[index] = curr;
    }
};

static_assert(sizeof(mmcau) == mmcau::size);

static volatile mmcau *const MMCAU = reinterpret_cast<mmcau *>(0xE0081000);

}; // namespace MIMXRT1176::CM4
